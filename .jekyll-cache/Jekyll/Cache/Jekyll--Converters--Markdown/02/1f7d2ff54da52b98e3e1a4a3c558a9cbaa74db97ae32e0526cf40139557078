I"!<h1 id="log-structured-file-system의-대두">Log-structured File System의 대두</h1>

<p>1990년 대 초, John Ousterhout 교수와 학생인 Mendel Rosenblum이 이끄는 버클리의 한 팀은 새로운 파일 시스템인 <code class="language-plaintext highlighter-rouge">Log-structured File System</code>을 개발하였습니다. 그들이 이 파일 시스템을 만들게 된 계기에는 총 네 가지가 있었지요.</p>

<ol>
  <li>
    <p><strong>시스템 메모리의 증가입니다.</strong> 메모리가 커질 수록, 더 많은 데이터들이 메모리에 <code class="language-plaintext highlighter-rouge">cache</code> 될 수 있었습니다. 그로 인해 더 많은 읽기 작업이 cache에서 행해지게 되었기 때문에, 디스크 트래픽에서 쓰기 작업의 비중이 급격하게 늘어나게 되었지요. 파일 시스템의 성능이 더더욱 쓰기 작업 성능에 의해 결정되게 된 것입니다.</p>
  </li>
  <li>
    <p><strong>늘어나는 랜덤 I/O와 연속적인 I/O 성능의 차이입니다.</strong> 하드 드라이브의 대역폭은 몇 년 동안 증가해왔습니다. 하지만, 그에 비해 <code class="language-plaintext highlighter-rouge">seek delay</code>와 <code class="language-plaintext highlighter-rouge">rotational delay</code>가 느려지게 되었지요. 더 빠르게 돌아가는 flatter와 더 빠르게 움직이는 디스크의 arm을 위한 싸고 작은 모터 제작은 굉장히 어려운 일이었습니다. 그렇기 때문에 seek와 rotation의 더 큰 성능은 디스크의 데이터들의 연속성에 더 많은 영향을 받게 된 것입니다.</p>
  </li>
  <li>
    <p><strong>당시의 파일 시스템들이 대부분이 작업들에 있어 굉장히 좋지 않은 성능을 가지고 있었다는 것입니다.</strong> 예를 들어 Fast File System 또한 오직 한 block의 파일을 새로이 생성하기 위해서 여러 쓰기 작업이 필요했습니다. 그래서 FFS가 이러한 많은 쓰기 작업을 해야 하는 block들 하나의 block 그룹으로 만들었더라도, 많은 seek과 rotational delay를 감당해야 했기에, 성능적으로 좋지 못할 수 밖에 없었지요.</p>
  </li>
  <li>
    <p><strong>파일 시스템들이 RAID를 인식하고 있지 않았던 것입니다.</strong> 예를 들어, RAID-4와 RAID-5 모두 하나의 작은 block을 logical하게 쓰는 작업이 physical 적으로 4번의 I/O를 발생시켰습니다. 당시의 파일 시스템들은 이러한 worst-case의 RAID 쓰기 작업을 피할 방도가 없었습니다.</p>
  </li>
</ol>

<p>이러한 이유들로 만들어진 Log-structured File System(LFS)는 처음에 메타 데이터를 포함한 모든 업데이트를 in memory의 segment안에 버퍼 시킵니다. 그리고 그 segment가 꽉 차게 되었을 때, 그것이 디스크가 쓰지 않는 부분에 한 번에 길고 연속적인 형태로 쓰는 것입니다. LFS는 절대 존재하는 데이터를 덮어쓰지 않고, 항상 free한 위치에 새로이 씁니다. 이 segment가 크기 때문에, 디스크나 RAID가 효율적으로 사용될 수 있으며, 파일 시스템의 성능이 절정에 달할 수 있게 되는 것이지요.</p>

<h2 id="디스크에-연속적으로-쓰기">디스크에 연속적으로 쓰기</h2>

<p><img src="/assets/img/os-log-structured/data_block.png" alt="data-block" width="80%" height="80%" /></p>

<p>우리가 T라는 시간 때, 파일에 D라는 데이터 block을 디스크 주소 A0에 쓰는 상황을 생각해 볼까요? 사용자가 데이터 block을 쓸 때 그에 해당하는 metadata까지 업데이트 해야 합니다. 파일의 데이터 block을 가리키는 inode 또한 디스크에 써야 하죠. 그 이후에 진행되는 모든 업데이트들을 디스크에 연속적으로 쓰는 것이 LFS의 핵심입니다.</p>

<p>그러나, 디스크에 연속적으로 쓰는 것 자체로는 효율적인 쓰기를 기대하기는 어렵습니다. 위와 같은 상황에서 <code class="language-plaintext highlighter-rouge">T + δ</code> 라는 시간에 연속적이기 위해 디스크 주소 A1에 새로운 쓰기를 시행한다고 생각해볼까요? 그러나 <code class="language-plaintext highlighter-rouge">δ</code>라는 시간 동안 디스크는 여러 번 돌아갈 것이기 때문에 쓰기를 위해 A1을 가리키려고 또 돌게 될 것입니다. 그래서 실제로 A1을 가리킬 때의 시간을 <code class="language-plaintext highlighter-rouge">T + T(rotation)</code>이라 하면 두 번째 쓰기를 commit하기 전까지 디스크는 <code class="language-plaintext highlighter-rouge">T(rotation) – δ</code> 만큼의 시간을 기다려야 하는 것입니다.</p>

<p><img src="/assets/img/os-log-structured/buffering.png" alt="buffering" width="80%" height="80%" /></p>

<p>이러한 문제를 해결하기 위해 LFS는 <code class="language-plaintext highlighter-rouge">write buffering</code>이라는 기술을 사용합니다. 디스크에 쓰기 전에 LFS는 in memory 상의 업데이트들을 계속해서 <code class="language-plaintext highlighter-rouge">tracking</code>합니다. 충분한 만큼의 업데이트가 모였을 때, 그것들을 한 번에 디스크에 씀으로써 효율적인 디스크 사용을 보장하는 것이죠. LFS가 한 번에 처리하는 이 여러 업데이트들의 모음을 <code class="language-plaintext highlighter-rouge">segment</code>라고 합니다. 위와 같이, 파일 j에 대한 4개 block의 업데이트와 파일 k에 대한 1개 block의 업데이트를 한 번에 모아 segemnt로 디스크에 쓰는 것입니다 segment가 크면 클 수록 효율성이 증가하는 것이죠!</p>

<h2 id="inode-찾기">inode 찾기</h2>

<p>FFS나 예전 Unix 파일 시스템과 같은 전형적인 파일 시스템에 있어 inode를 찾는 것은 쉽습니다. 왜냐하면 그것들이 배열의 형태로 조직화 되었으며, 디스크의 고정된 위치에 위치하기 때문이지요. 예를 들어 예전 Unix 시스템은, 모든 inode를 디스크의 고정된 위치에 유지합니다. 그렇기에 inode를 찾기 위해 inode 번호와 시작 주소만 안다면 주소에 inode의 번호와 크기를 곱한 값을 더하기만 하면 되겠지요? 이러한 배열 기반의 indexing은 빠르고 직관적입니다. FFS에서는 inode 테이블을 여러 그룹으로 나누어 각각의 cylinder group에 위치시킨 다는 걸 공부했습니다. 그렇기 때문에 각 그룹의 시작 위치와 크기를 알아야 하기 때문에 조금 더 복잡하다고 할 수 있는 것이지요.</p>

<p>그런데 LFS는 이보다 더 어렵습니다. 모든 inode들이 각자 디스크에 흩뿌려져 있기 때문입니다!:dizzy_face: 더군다나 절대 그 위치에 덮어쓰지 않기 때문에, inode의 최신 버전은 계속해서 움직이고 있는 것이지요.</p>

<p>이를 위해, LFS의 디자이너들은 inode 번호와 inode 사이에 <code class="language-plaintext highlighter-rouge">Inode Map(imap)</code>이란 자료 구조로 Level of Indirection 개념을 도입하였습니다. imap은 inode 번호를 입력 값으로 받고 inode의 가장 최신 버전의 디스크 주소를 생성합니다. inode가 쓰일 때마다, imap이 그것의 새로운 위치를 업데이트합니다. 이렇게 imap은 지속성을 가져야 하기에 디스크에서 고정적인 부분에 위치해야 할 것입니다. 그러나 이렇게 된다면 데이터 block과 inode를 쓴 뒤 다시 imap으로 이동하기 위해 더 많은 디스크 seek이 소요되기 때문에 성능이 떨어지게 되겠지요? 그래서 LFS는 imap 또한 새로운 데이터를 쓴 곳 바로 다음에 위치시킵니다.</p>

<p><img src="/assets/img/os-log-structured/checkpoint.png" alt="checkpoint" width="80%" height="80%" /></p>

<p>흩뿌려져 있는 inode를 찾기 위해 inode map을 도입했는데… 이제는 inode map이 디스크 곳곳에 퍼져 있네요? 이렇게 되니 이제는 inode map을 어떻게 찾을 지가 문제가 되는 것입니다. 더 이상은 어쩔 수 없습니다. 파일 lookup을 시작하기 위해 디스크에 고정되고 알려진 위치를 확보해야 합니다. LFS는 이와 같은 위치(공간)을 <code class="language-plaintext highlighter-rouge">check-point region(CR)</code>이라 합니다. CR은 가장 최근 inode map에 대한 포인터를 가지고 있습니다. CR은 매 업데이트 때마다 업데이트 되는 것이 아니라 오직 주기적으로 업데이트 되기 때문에, 성능을 크게 해치지 않게 됩니다.</p>

:ET