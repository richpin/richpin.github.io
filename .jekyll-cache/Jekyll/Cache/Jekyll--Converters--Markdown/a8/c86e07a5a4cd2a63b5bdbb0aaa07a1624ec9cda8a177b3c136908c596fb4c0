I"<h1 id="log-structured-file-system의-대두">Log-structured File System의 대두</h1>

<p>1990년 대 초, John Ousterhout 교수와 학생인 Mendel Rosenblum이 이끄는 버클리의 한 팀은 새로운 파일 시스템인 Log-structured File System을 개발하였습니다. 그들이 이 파일 시스템을 만들게 된 계기에는 총 네 가지가 있었지요.</p>

<ol>
  <li>
    <p><strong>시스템 메모리의 증가입니다.</strong> 메모리가 커질 수록, 더 많은 데이터들이 메모리에 cache 될 수 있었습니다. 그로 인해 더 많은 읽기 작업이 cache에서 행해지게 되었기 때문에, 디스크 트래픽에서 쓰기 작업의 비중이 급격하게 늘어나게 되었지요. 파일 시스템의 성능이 더더욱 쓰기 작업 성능에 의해 결정되게 된 것입니다.</p>
  </li>
  <li>
    <p><strong>늘어나는 랜덤 I/O와 연속적인 I/O 성능의 차이입니다.</strong> 하드 드라이브의 대역폭은 몇 년 동안 증가해왔습니다. 하지만, 그에 비해 Seek delay와 rotational delay가 느려지게 되었지요. 더 빠르게 돌아가는 flatter와 더 빠르게 움직이는 디스크의 arm을 위한 싸고 작은 모터 제작은 굉장히 어려운 일이었습니다. 그렇기 때문에 seek와 rotation의 더 큰 성능은 디스크의 데이터들의 연속성에 더 많은 영향을 받게 된 것입니다.</p>
  </li>
  <li>
    <p><strong>당시의 파일 시스템들이 대부분이 작업들에 있어 굉장히 좋지 않은 성능을 가지고 있었다는 것입니다.</strong> 예를 들어 Fast File System 또한 오직 한 block의 파일을 새로이 생성하기 위해서 여러 쓰기 작업이 필요했습니다. 그래서 FFS가 이러한 많은 쓰기 작업을 해야 하는 block들 하나의 block 그룹으로 만들었더라도, 많은 seek과 rotational delay를 감당해야 했기에, 성능적으로 좋지 못할 수 밖에 없었지요.</p>
  </li>
  <li>
    <p><strong>파일 시스템들이 RAID를 인식하고 있지 않았던 것입니다.</strong> 예를 들어, RAID-4와 RAID-5 모두 하나의 작은 block을 logical하게 쓰는 작업이 physical 적으로 4번의 I/O를 발생시켰습니다. 당시의 파일 시스템들은 이러한 worst-case의 RAID 쓰기 작업을 피할 방도가 없었습니다.</p>
  </li>
</ol>

<p>이러한 이유들로 만들어진 Log-structured File System(LFS)는 처음에 메타 데이터를 포함한 모든 업데이트를 in memory의 segment안에 버퍼 시킵니다. 그리고 그 segment가 꽉 차게 되었을 때, 그것이 디스크가 쓰지 않는 부분에 한 번에 길고 연속적인 형태로 쓰는 것입니다. LFS는 절대 존재하는 데이터를 덮어쓰지 않고, 항상 free한 위치에 새로이 씁니다. 이 segment가 크기 때문에, 디스크나 RAID가 효율적으로 사용될 수 있으며, 파일 시스템의 성능이 절정에 달할 수 있게 되는 것이지요.</p>

<h2 id="디스크에-연속적으로-쓰기">디스크에 연속적으로 쓰기</h2>

<p><img src="/assets/img/os-log-structured/data_block.png" alt="data-block" width="80%" height="80%" /></p>

<p>우리가 T라는 시간 때, 파일에 D라는 데이터 block을 디스크 주소 A0에 쓰는 상황을 생각해 볼ㅏ요? 사용자가 데이터 block을 쓸 때 그에 해당하는 metadata까지 업데이트 해야 합니다. 파일의 데이터 block을 가리키는 inode 또한 디스크에 써야 하죠. 그 이후에 진행되는 모든 업데이트들을 디스크에 연속적으로 쓰는 것이 LFS의 핵심입니다.</p>

<p>그러나, 디스크에 연속적으로 쓰는 것 자체로는 효율적인 쓰기를 기대하기는 어렵습니다. 위와 같은 상황에서 T + δ 라는 시간에 연속적이기 위해 디스크 주소 A1에 새로운 쓰기를 시행한다고 생각해볼까요? 그러나 δ라는 시간 동안 디스크는 여러 번 돌아갈 것이기 때문에 쓰기를 위해 A1을 가리키려고 또 돌게 될 것입니다. 그래서 실제로 A1을 가리킬 때의 시간을 T + T(rotation)이라 하면 두 번째 쓰기를 commit하기 전까지 디스크는 T(rotation) – δ 만큼의 시간을 기다려야 하는 것입니다.</p>

<p>이러한 문제를 해결하기 위해 LFS는 write buffering이라는 기술을 사용한다. 디스크에 쓰기 전에 LFS는 in memory 상의 업데이트들을 계속해서 tracking한다. 충분한 만큼의 업데이트가 모였을 때, 그것들을 한 번에 디스크에 씀으로써 효율적인 디스크 사용을 보장하는 것이다. LFS가 한 번에 처리하는 이 여러 업데이트들의 모음을 segment라고 한다. segment가 크면 클 수록 효율성이 증가하는 것이다.</p>

:ET