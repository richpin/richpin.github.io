I"<p>이번에는 <strong>Semaphore</strong>에 대해 알아보도록 합시다.</p>

<h1 id="semaphore란-무엇일까">Semaphore란 무엇일까?</h1>

<p>우리가 흔히 <code class="language-plaintext highlighter-rouge">Dijkstra Algorithm</code>으로 잘 알고 있는 Dijkstra는 공유 자원에 대한 접근을, 즉 동기화 문제를 위해 <code class="language-plaintext highlighter-rouge">Semaphore</code>라는 것을 만들었습니다. 우리는 이전에 배웠던 <code class="language-plaintext highlighter-rouge">Locks</code>와 <code class="language-plaintext highlighter-rouge">Condition Variables</code> 대신 이 하나의 Semaphore라는 것을 이용할 수 있는 거지요. 단순하게 생각하면 Semaphore는 그저 두 개의 <code class="language-plaintext highlighter-rouge">atomic operation</code>으로 관리되는 하나의 정적 변수에 불과한 개념입니다. 내용은 아래와 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;semaphore.h&gt; 
</span><span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>
<span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//performed atomically</span>
       <span class="n">decrement</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">by</span> <span class="n">one</span>
       <span class="n">wait</span> <span class="k">if</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">is</span> <span class="n">negative</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//performed atomically</span>
       <span class="n">increment</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">by</span> <span class="n">one</span>
       <span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">one</span> <span class="n">or</span> <span class="n">more</span> <span class="n">threads</span> <span class="n">waiting</span><span class="p">,</span> <span class="n">wake</span> <span class="n">one</span>
<span class="p">}</span>
</code></pre></div></div>
<p>init의 마지막 parameter에서 Semaphore의 값을 초기화 합니다. <code class="language-plaintext highlighter-rouge">sem_wait</code>은 단순히 값을 1 줄입니다. 그리고 그 값이 음수가 된다면 <code class="language-plaintext highlighter-rouge">wait 상태(Sleeping State)</code>에 들어가게 됩니다. <code class="language-plaintext highlighter-rouge">sem_post</code>는 단순히 값을 1 증가합니다. 이 때 wait 상태에 있는 스레드들이 존재한다면 그 중 하나를 깨웁니다. 기본적인 사용법은 아래와 같이 <code class="language-plaintext highlighter-rouge">Critical Section</code>을 wait과 post로 감싸줍니다.</p>

<p><img src="/assets/img/os-semaphore/semaphore_basic.png" alt="semaphore-basic" width="30%" height="30%" /></p>

<p>간단히 정리하자면 이와 같습니다. 아래의 그림과 함께 보시죠.</p>

<p><img src="/assets/img/os-semaphore/semaphore_example.png" alt="semaphore-exmaple" width="80%" height="80%" /></p>

<p>먼저 Semaphore값을 처음 1로 설정하는 이유는 <strong>Critical Section에 들어갈 수 있는 스레드</strong>가 하나여야 하기 때문입니다. 값이 1인 상태에서 어떠한 스레드가 Critical Section을 수행하기 위해 wait을 호출하면 값은 0이 됩니다. 이 상황에서 그 스레드가 post를 호출하여 다시 값을 1로 올릴 수도 있습니다. 그러나, 그 전에 다른 스레드가 Critical Section에 접근하기 위해 wait을 실행하면 값이 -1이 되고 Sleeping State에 들어가게 됩니다. 이런 식으로 어떤 스레드가 Critical Section을 수행 중일 때 다른 스레드가 접근해봤자 계속해서 값이 <code class="language-plaintext highlighter-rouge">-2, -3, -4 ...</code>식으로 줄어들게 됩니다. 이를 통해, 우리는 값의 음수 절대값이 <strong>waiting 상태의 스레드 수</strong>와 같다는 점을 알 수 있습니다. 이 상황에서 post를 하게 된다면 waiting인 중인 한 스레드가 깨서 Critical Section을 수행하게 되며 값을 1 증가시키기 때문에 음수의 절대값은 1 줄어들어 waiting 상태의 스레드 수를 정확히 반영하는 것을 확인할 수 있습니다. Critical Section의 수행을 제한하기 때문에 <code class="language-plaintext highlighter-rouge">Locks</code>의 기능, 스레드를 wait시키고 wake하기 때문에 <code class="language-plaintext highlighter-rouge">Condition Variables</code>의 기능을 모두 수행할 수 있다고 말할 수 있는 것입니다.</p>

:ET