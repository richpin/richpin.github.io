I"A<p>이번 시간에는 OS와 I/O로 소통하는 Device들에 대해 알아봅시다. 먼저 간단한 컴퓨터 시스템 구조부터 확인해볼까요?</p>

<p><img src="/assets/img/os-device/system_architecture.png" alt="system_architecture" width="50%" height="50%" /></p>

<p>시스템은 이와 같이 <code class="language-plaintext highlighter-rouge">Hierarchical</code> 구조를 띄고 있습니다. 가장 상단의 CPU와 Memory는 서로 <code class="language-plaintext highlighter-rouge">Memory bus</code>를 사용해서 데이터를 주고 받습니다. 아시다시피 모든 <code class="language-plaintext highlighter-rouge">bus</code> 중에 가장 빠르겠구요. 그 밑에는 모니터, 마우스, 키보드와 같은 주변기기들과 컴퓨터 메인보드를 연결하는 <code class="language-plaintext highlighter-rouge">I/O bus</code>가 위치합니다. 그리고 최하단에는 가장 느리지만 가장 용량이 큰 저장장치들이 <code class="language-plaintext highlighter-rouge">Peripheral bus</code>로 연결되어 있지요. 흔히 <code class="language-plaintext highlighter-rouge">Hardware</code>라고도 불리는 이 저장 장치에는 <code class="language-plaintext highlighter-rouge">SCSI</code>, <code class="language-plaintext highlighter-rouge">SATA</code>, 그리고 우리가 흔히 아는 <code class="language-plaintext highlighter-rouge">USB</code> 같은 프로토콜을 가집니다. 지금 우리가 공부할 부분이 바로 이 부분입니다.</p>

<p>Device에는 시스템 소프트웨어들이 제어를 할 수 있도록 3개의 <code class="language-plaintext highlighter-rouge">Hardware Interface Register</code>를 가집니다. 이는 아래와 같습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Status Register</code> : 디바이스의 현 상태를 확인하기 위해 읽어들이는 레지스터 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Command Register</code> : 디바이스에게 어떠한 task를 수행하도록 명령하기 위해 쓰는 레지스터 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Data Register</code> : 디바이스와 데이터를 주고받기 위한 레지스터입니다.</li>
</ol>

<p>내부 구조에 따라 Device도 크게 두 가지로 나뉠 수 있습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Simple Device</code> : 기능을 제공하기 위해 한 개 정도의 적은 <code class="language-plaintext highlighter-rouge">chip</code> 만을 가지는 디바이스 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Complex Device</code> : 단순히 몇몇 chip을 가지는 것을 넘어 아래와 같이 고유의 <code class="language-plaintext highlighter-rouge">fireware</code> 가 등록되어 있는 작은 <code class="language-plaintext highlighter-rouge">CPU</code>, CPU와 함께 동작하는 <code class="language-plaintext highlighter-rouge">Memory</code>, 그리고 다양한 용도의 많은 <code class="language-plaintext highlighter-rouge">chip</code>을 가짐으로 하나의 작은 컴퓨터로서 동작하는 디바이스 입니다.</li>
</ol>

<p><img src="/assets/img/os-device/complex_device.png" alt="complex_device" width="40%" height="40%" /></p>

<p>위에서 설명한 레지스터를 이용하여 컴퓨터는 간단하게 아래와 같이 디바이스와 소통할 수 있습니다.</p>

<p><img src="/assets/img/os-device/protocol_problem.png" alt="protocol_problem" width="40%" height="40%" /></p>

<p>그러나 위와 같이 수행할 경우 두 가지의 심각한 비효율성 문제가 야기 됩니다. 첫 번째는 CPU가 쉬지 안고 계속해서 Status register를 읽기 때문에(poll) CPU의 낭비가 야기됩니다. 이 문제를 <code class="language-plaintext highlighter-rouge">Polling</code>이라 부릅니다. 두 번째는 컴퓨터의 메인 <code class="language-plaintext highlighter-rouge">CPU</code>가 데이터의 교환을 위해 직접 움직이기 때문에 마찬가지로 CPU의 낭비가 야기됩니다. 이 문제를 <code class="language-plaintext highlighter-rouge">Programmed I/O(PIO)</code>라 부릅니다.</p>

<h1 id="interrupt를-이용하자">Interrupt를 이용하자</h1>

<p><img src="/assets/img/os-device/interrupt.png" alt="interrupt" width="40%" height="40%" /></p>

<p>위 두 문제를 해결하기 위해 도입된 것이 바로 <code class="language-plaintext highlighter-rouge">Interrupt</code>입니다. OS가 <code class="language-plaintext highlighter-rouge">I/O request</code>를 감지하면 해당 프로세스(그림의 A)를 <code class="language-plaintext highlighter-rouge">Sleep</code> 시킨 후, <code class="language-plaintext highlighter-rouge">Context Switch</code>를 해서 다른 프로세스(그림의 B)를 실행시킵니다. 그리고 디바이스가 요청된 작업이 다 끝나는 순간 <code class="language-plaintext highlighter-rouge">Hardware Interrupt</code>를 발생시킵니다. 그러면 CPU는 OS의 <code class="language-plaintext highlighter-rouge">Interrupt Service Routine(ISR)</code>을 동작시킨 후 I/O를 기다리며 Sleep하고 있던 프로세스(그림의 A)를 깨우게 됩니다. 이런식으로 Computation과 I/O가 어느 정도 겹쳐서 동작하게끔 함으로써 Poling과 PIO문제를 해결할 수 있는 것입니다.</p>

<p>그러나 만약 디바이스가 너무 빨라서 순식간에 interrupt를 할 경우에는 어떨까요? Context Switching을 할 시간조차 없겠죠? 즉, Interrupt를 하는 의미가 없어지게 되는 것입니다. 이럴 때는 그냥 <code class="language-plaintext highlighter-rouge">poll</code>을 하는 방식이 더 효과적일 수 있습니다. 그래서 보통은 처음엔 poll을 하다가 디바이스가 빨리 도착하지 않으면 어느 시점에서 Interrupt 모드로 전환하는 <code class="language-plaintext highlighter-rouge">Two-phased Approach</code>즉 <code class="language-plaintext highlighter-rouge">Hybrid</code> 방식을 채택하고는 합니다.</p>

<p>예를 들어, 네트워크 시스템을 생각해 봅시다. 여기서는 평화롭다가도 어느 시점에서 패킷이 들어오게 되면 엄청난 양의 스트림에 대해서 계속해서 Interrupt가 발생하게 됩니다. 자칫하면 OS가 <code class="language-plaintext highlighter-rouge">Livelock</code>에 걸리게 되는 것이지요. 이럴 때는 오히려 패킷이 들어오기 시작할때 Poll 모드를 사용하는 것이 바람직한 방법이게 됩니다.</p>

<p>그래도 Poll 모드가 맘에 들지 않는다구요? 그렇다면 Interrupt 발생 overhead를 줄이기 위해 여러 번의 Interrupt를 하나의 Interrupt로 합쳐서 받아들이는 방법도 있겠습니다. 이를 <code class="language-plaintext highlighter-rouge">Interrupt Coalescing</code>이라고 합니다. 그러나, 합쳐질 만큼 많은 Interrupt를 기다려야 하기 때문에 request의 <code class="language-plaintext highlighter-rouge">Latency</code>가 올라가는 단점이 존재하게 됩니다.</p>

<h1 id="dma를-이용하자">DMA를 이용하자</h1>

:ET