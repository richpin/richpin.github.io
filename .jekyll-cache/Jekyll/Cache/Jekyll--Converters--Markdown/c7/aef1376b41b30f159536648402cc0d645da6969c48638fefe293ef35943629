I"'<p>Android 개발자로 추후 진로를 결정할 생각은 없지만, 어찌다 보니 지금 하고 있는 프로젝트가 안드로이드 어플리케이션이네요. <del>(그래도 아직은 생각 없습니다)</del>
나름 Google Playstore에도 올려서 서비스를 진행할 어플리케이션이라 안정성을 신경써야 하기 때문에 <strong>ViewModel</strong> 이란 개념을 도입해서 개발하기로 했습니다.</p>

<p>새로운 개념이니만큼 이해하기 <strong>쉽게</strong> 그리고 개발을 위해 최소한으로 필요한 만큼만 설명을 하는 방향으로 잡겠습니다.:smile:</p>

<h2 id="mvvm이란">MVVM이란?</h2>

<p>ViewModel을 알기 전 MVVM이란 개념을 알아야하는데, ViewModel이 여기서 파생되었기 때문입니다.</p>

<p><img src="/assets/images/MVVM_handmade.png" alt="MVVMPattern" />
<del>(발그림 죄송합니다ㅎㅎ)</del></p>

<p><strong>MVVM(Model-View-ViewModel)</strong> 패턴은 하나의  코드에서 사용자에게 보여지는 GUI 부분, 즉 <strong>View</strong> 를 비즈니스 로직(모델)로부터 분리하여 독립적인 역할로써 존재하게 하는 Software Architecture 패턴입니다. 쉽게 말해서 GUI와 관련된 코드들을 관련없는 다른 코드들과 분리시켜서 <strong>독립적</strong> 으로 존재하게 하고 싶다는 겁니다.
기술이 발전할수록 개발되는 프로그램들은 점점 거대하져 가기에 기능에 있어 역할들을 세분하여 독립적이게 하는 것도 점점 중요한 주제가 되어가고 있죠? MVVM은 이 View에 있어 그런 니즈를 충족시키위해 태어났다고 보시면 됩니다.</p>

<ol>
  <li>View에서는 사용자가 스크린에서 보이는 <strong>UI</strong> 적인 요소만 독립적으로 정의합니다. 오직 어떻게 보일지에 대한 것만 구현한다는 뜻이죠. ViewModel의 변화에 맞춰 사용자에게 보이는 부분에도 변화를 주는 것이지요.</li>
  <li>Model에서는 해당 프로그램에서 사용할 <strong>Data</strong> 와 그 Data에 대한 처리들을 정의합다. 네트워크 통신과 관련되어 있는 부분이라 생각하면 편할겁니다. 서버와 커뮤니케이션 하여 data들을 보내고 가져오고 계산하는 등의 과정을 <strong>독립적</strong> 으로 맞게 되는 것입니다.</li>
  <li>ViewModel에서는 위의 그림과 마찬가지로 이 View와 Model의 <strong>다리</strong> 가 되어준다고 생각하면 됩니다. Model과 커뮤니케이션하여 데이터들을 가져와 이를 알맞게 가공하여 View가 오직 이 데이터들을 <strong>표현</strong> 하는데에만 집중할 수 있도록 조력자 역할을 합니다.</li>
</ol>

<p>이렇게 분리해 놓으면 작업이 병렬적으로 진행될 수 있게 되어 테스트와 유지 및 보수 등이 한결 효율적이게 진행되므로 전체적인 안정성에 크게 기여하게 되는 것입니다.</p>

<h2 id="android의-viewmodel">Android의 ViewModel</h2>

<p>Android에서 View는 ‘UI 컨트롤러’라고 부릅니다. 저희가 이미 아는 Activity, Fragment가 이 UI 컨트롤러에 포함되는 것이죠. 앞선 ViewModel의 장점과 더불어 Android내에서 ViewModel은 추가적으로 한 가지의 장점을 더 가지게 되는데 바로 <strong>Life cycle(생명주기)</strong> 입니다.</p>

<p>UI 컨트롤러(View)에서 관련 데이터를 저장하고 있게 되면 당연하게도 해당 UI 컨트롤러가 제거될 때 관련 데이터 또한 제거되게 되겠죠?? 이렇게 되면 UI 컨트롤러가 재생성 되게 될 때 관련 데이터 또한 다시 불러와야 하는 비효율적 문제가 생기게 됩니다. 대표적인 예시가 회전인데 Android에서 화면을 회전하게 될 때 UI 컨트롤러가 삭제 후 재생성이 되는데 사용하는 관점에서는 화면만 달라지는 것이 전부여야 하지만 UI가 재생성 되면서 데이터들까지 달라지는 참사가 생기게 되는 것이죠. (기존에는 <code class="language-plaintext highlighter-rouge">Bundle</code>을 사용해서 해결했지만, 이제는 성능의 한계에 부딪히게 되버렸다고 합니다.:sweat_smile:)</p>

<p><img src="/assets/images/viewmodel-lifecycle.png" alt="viewmodel-lifecycle" /></p>

<p>이와 같이 UI 컨트롤러와 상관없이 ViewModel이 UI 컨트롤러의 LifeCycle을 모두 포함하는 독립적인 Life Cycle을 갖게 되면서 UI 컨트롤러의 변동에도 데이터는 유지할 수 있게 되는 가장 큰 장점이 생기게 됩니다. 스마트폰의 성능이 향상되고 사용자의 활용이 복잡해지면서(어플리케이션 실행 중에 이것 저것 다른 활동을 하는 경우) ViewModel은 선택이 아닌 필수가 되었다고 할 수 있겠죠???</p>

<p>Android에서 구현되는 MVVM 패턴은 다음과 같습니다.</p>

<p><img src="/assets/images/final-architecture.png" alt="final-architecture" /></p>

<p>MVVM 개념에서 Activity/ Fragment가 View임은 위에서 설명했고, 추가적으로 Repository가 Model이 되는 것이다. Repository에서 또 데이터 베이스와 웹 서비스 관련 Model들과 소통이 이루어짐을 보여줍니다. 위에서 생소한 것이 LiveData일 것일 텐데요.</p>

<p><strong>LiveData</strong> 는 ViewModel에서 데이터를 담고 있게 해주는 Holder 클래스입니다. LiveData는 UI 컨트롤러가 Data의 변경을 <strong>관찰(모니터링)</strong> 할 수 있는 클래스입니다. 따라서 ViewModel이 이 LiveData라는 것을 통해 UI 컨트롤러에게 ‘야! 데이터 바뀌었어! 일해!!!”라고 해주는 것이지요. LiveData가 다른 클래스와 다른 가장 큰 특징은 LifeCycle을 인식한다는 점입니다. UI 컨트롤러의 LifeCycle에 따라 Active한 상태에서만 Model과 커뮤니케이션하여 Data를 업데이트함으로써 동기화, 메모리, 비정상 종료, 자동화 등의 많은 측면에서 엄청난 장점을 가지게 됩니다.</p>

<h2 id="android에서-viewmodelmvvm-구현">Android에서 ViewModel(MVVM) 구현</h2>

<p>제가 찾기로 한국 블로그에 설명은 많은데 코드를 보여주며 설명해주는 곳이 많지 않았습니다. 그래서 저와 함께 간단히 살펴볼텐데요. 외국 블로그에서 여러 능력자분들이 쓰신 여러가지 방식의 코드들이 있습니다만, 저는 제가 직접 프로젝트에 사용하였던 방식으로 예시를 들어보겠습니다. 이 때 배웠단 간간한 다른 지식들까지 말씀드릴테니 천천히 따라와 보시죠! 간단하게 사용자 정보를 다루는 MVVM을 구현해보도록 하겠습니다.</p>

<p>가장 먼저, ViewModel 작성을 해봅시다. 사용자 정보에 대한 ViewModel이니 class이름을 UserViewModel이라 칭하겠습니다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UserViewModel</span> <span class="p">:</span> <span class="nc">ViewModel</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">users</span> <span class="p">=</span> <span class="nc">MutableLiveData</span><span class="p">&lt;</span><span class="nc">ArrayList</span><span class="p">&lt;</span><span class="nc">User</span><span class="p">&gt;&gt;()</span>
<span class="p">}</span>
</code></pre></div></div>
<p>사용자 정보를 담은 User라는 데이터 클래스를 담은 ArrayList을 LiveData로 감싸고 있는 모습입니다. ArrayList<User>대신 어떤 타입이든 사용자가 필요한 자료형을 그때그때 넣어서 감싸주시면 됩니다.</User></p>

<p>이제 함수를 사용자 정보를 가져오는 함수를 만들어볼까요. Repository에 데이터 베이스로부터 사용자 정보를 가져오는 코드를 작성합니다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">object</span> <span class="nc">Repository</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">getUsers</span><span class="p">()</span> <span class="p">=</span> <span class="nf">callbackFlow</span> <span class="p">{</span>
        <span class="o">..</span><span class="p">.</span>
        <span class="nf">trySend</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>갑자기 <code class="language-plaintext highlighter-rouge">callbackFlow</code>가 뭐냐 하실수도 있는 저와같은 분이 계실겁니다. 이 <code class="language-plaintext highlighter-rouge">getUsers</code>함수처럼 네트워크와 통신을 한다면 통신에 의한 시간이 걸리겠죠? 평소에는 괜찮다 하더라도 만약 이 시간이 내가 작성한 코드를 컴퓨터가 진행하는 속도보다 오래 걸린다면 문제가 생기는 것입니다. 이 통신은 코드 진행과는 별개로 <del>(정확한 표현은 아니지만…)</del> 일어나고 있기 때문에 <code class="language-plaintext highlighter-rouge">user</code>을 가져오기도 전에 프로그램은 이미 <code class="language-plaintext highlighter-rouge">user</code>을 가져온 이후의 코드들을 실행시키고 있는 것이지요. 그것을 막아주기 위해 <code class="language-plaintext highlighter-rouge">kotlin</code>에서는 이와 같은 방식으로 좀 그때그때마다 기다려달라는 의사를 전달하고 있는 것입니다. user라는 사용자 정보를 가져오는 것이 끝났다면 <code class="language-plaintext highlighter-rouge">trySend</code>로 데이터를 쏴줌으로써 이어서 진행하라는 의사까지 전달하는 것입니다. 이와 같은 방식을 <code class="language-plaintext highlighter-rouge">callback</code>이라고 하는데 더 알아보고 싶으신 분들은 정말 많은 좋은 글들과 자료들을 참고하여 공부하시면 좋을 것 같습니다.</p>
:ET