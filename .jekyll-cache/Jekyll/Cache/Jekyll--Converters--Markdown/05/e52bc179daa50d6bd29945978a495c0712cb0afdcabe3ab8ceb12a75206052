I"<p>이번에는 <strong>Thread(스레드)</strong>에 대해 알아보도록 합시다.</p>

<h1 id="thread란-무엇일까">Thread란 무엇일까?</h1>

<p><code class="language-plaintext highlighter-rouge">Thread</code>의 기본적인 정의는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 뜻합니다. 흔히 우리가 아는 프로레스는 사실 하나의 프로그램이고 그 프로세스는 적어도 하나의 이상의 스레드를 가지게 되는 것이죠. 같은 코드를 실행하는 각기 다른 <code class="language-plaintext highlighter-rouge">Program Counter</code>가 있다고 생각하시면 쉬울 겁니다. 스레드는 <code class="language-plaintext highlighter-rouge">address space</code>를 공유합니다. 즉 같은 코드와 데이터를 가지고 각기 다른 부분을 실행하는 것이지요. 다만 각각의 스레드는 자신만의 <code class="language-plaintext highlighter-rouge">stack</code>과 <code class="language-plaintext highlighter-rouge">register(including PC)</code>을 가지게 됩니다. 병렬성을 위한 존재하는 만큼 context switching이 가능하며 그 단위로 <code class="language-plaintext highlighter-rouge">TCB(Thread Control Block)</code>을 가집니다. 요즘 대부분의 프로그램들은 <code class="language-plaintext highlighter-rouge">Mult-threaded</code>로 만들어지고 있죠.</p>

<p>왜 우리는 스레드를 사용해야 할까요?</p>

<ul>
  <li>Parallelism - 여러 개의 processor가 장착된 컴퓨터에서 여러 스레드를 돌린다면 빨라지겠죠?</li>
  <li>I/O overraping - 하나의 프로세서라도 어떤 스레드가 I/O를 기다리고 있는 동안 다른 스레드가 돌아간다면 매우 효율적일 것입니다.</li>
  <li>light-weight - 프로세스보다 스레드를 만드는 것이 훨씬 가벼운 작업입니다.</li>
</ul>

<blockquote>
  <p><strong>스레드는 데이터를 공유한다</strong></p>
</blockquote>

<p>다만, 이와 같은 특징으로 인해 <code class="language-plaintext highlighter-rouge">logically separate</code>한 task에서는 스레드보다 프로세스가 더 나을 수 있습니다. 그러나 같은 코드를 나누어 동시적으로 실행한다는 장점 때문에 어플리케이션들에서는 <code class="language-plaintext highlighter-rouge">Update display</code>, <code class="language-plaintext highlighter-rouge">Fetch data</code>, <code class="language-plaintext highlighter-rouge">Answer a network request</code>와 같이 해야하는 일을 동시다발적으로 돌려 빠르게 효율성을 극대화하고 있습니다.
(+ 커널 또한 Multithreaded입니다.)</p>

<p>다시 정리하자면,</p>

<ul>
  <li>Responsiveness - 프레세스의 어느 부분이 잠시 막히더라도, 더 <code class="language-plaintext highlighter-rouge">user interface</code>와 같이 더 중요한 작업들을 계속해서 해나갈 수 있습니다.</li>
  <li>Resource Sharing - 스레드의 가장 큰 특징으로 스레드들끼리는 리소스를 공유합니다.</li>
  <li>Economy - 프로세스보다 훨씬 가볍습니다.</li>
  <li>Scalability - 멀티 프레세스 시스템에서 프로세스들이 이득을 볼 수 있는 것은 다 스레드가 있기에 가능한 일입니다.</li>
</ul>

<h1 id="thread의-치명적-문제점">Thread의 치명적 문제점</h1>

<p>데이터를 공유한다는 스레드의 가장 큰 특징은 사실 스레드의 가장 큰 약점이 되기도 합니다.
아와 같은 상황을 생각해 봅시다.</p>

<p><img src="/assets/img/os_thread/uncontrolled_scheduling.png" alt="uncontrolled_scheduling" width="60%" height="60%" /></p>

<p><code class="language-plaintext highlighter-rouge">counter = counter + 1</code>이라는 코드를 수행하는 과정입니다. 내부적으로 위와 같이 fetch하고 add연산한 뒤 store하는 일련의 어셈블리 과정을 내포하고 있죠. 그런데 만약 한 스레드가 fetch하고 add를 하는데 store를 하기 전에 다른 스레드로 context switching이 일어났다고 생각해 봅시다. 그렇다면 이 스레드는 전 스레드가 업데이트를 하기 전의 값을 fetch하게 됩니다. 결과적으로 두 스레드가 모두 store하는 값은 51로 같은 값이 되기 때문에 두 번의 연산으로 예상되는 결과가 벌어지지 않는 것입니다. 이를 <code class="language-plaintext highlighter-rouge">indeterminate</code>하다라고 표현하며 이와 같은 상황을 <strong>Race Condition</strong>이라고 합니다.</p>

<ul>
  <li><strong>Race Condition</strong> - 위와 같이 실행 시점의 타이밍이 맞지 않는 문제로 indeterminaate하게 이루어지는 결과를 뜻합니다
    <ul>
      <li><strong>Critical Section</strong> - <code class="language-plaintext highlighter-rouge">shared variable</code>에 접근하는 구역으로, Race Condition을 방지하기 위해 두 개 이상의 스레드가 실행되서는 안되는 구역입니다.</li>
      <li><strong>Mutual Exclusion</strong> - 한 스레드가 Critical Section을 실행하고 있을 때 다른 스레드가 해당 Critical Section을 실행하지 못하게 보장하는 것입니다.</li>
    </ul>
  </li>
</ul>

<p>따라서 우리는 한 번에 끝내야 하는 코드 section을 보장해야합니다. 이를 위해 해당 코드 section 수행 중 다른 스레드로 context switching이 일어나는 것을 방지해야 한다는 것을 의미하기도 합니다. 이를 <em>atomic</em>해야 한다고 말하기도 합니다. atomic은 중간에 멈추는 것 없이 아예 다 실행이 안되거나 아예 다 실행히 한 번에 이루어져야 함을 뜻합니다.</p>

<blockquote>
  <p>감사하게도 많은 복잡한 atomic instruction 필요 없이, 하드웨어가 synchronization primitives를 위한 몇 가지 명령어들을 제공합니다.</p>
</blockquote>

<h1 id="race-condition을-해결하기-위한-방법">Race Condition을 해결하기 위한 방법</h1>

<p>첫 번째로는</p>
:ET