I"L$<p>OS에서 발생할 수 있는 <code class="language-plaintext highlighter-rouge">Concurrency Bugs</code>에는 크게 <code class="language-plaintext highlighter-rouge">Non-Deadlock</code>과 <code class="language-plaintext highlighter-rouge">DeadLock</code>이 있습니다. 먼저 Non-Deadlock에 대해 알아봅시다.</p>

<h1 id="non-deadlock-bugs">Non-Deadlock Bugs</h1>

<p><img src="/assets/img/os_concurrency_problem/atomicity_violation.png" alt="atomicity-violation" width="60%" height="60%" /></p>

<p>그림의 왼쪽과 같은 MySQL문을 봅시다. Thread1과 Thread2가 모두 thd-&gt;proc_info에 접근한다면 <code class="language-plaintext highlighter-rouge">atomicity</code>가 보장되지 않습니다. 이를 <code class="language-plaintext highlighter-rouge">Atomicity-Violation Bugs</code>라고 합니다. 그래서 우리느 오른쪽과 같이 <code class="language-plaintext highlighter-rouge">Lock</code>을 사용해 atomicity를 보장해야 하는 것이죠. 전에 공부하였던 Lock의 의의와는 직결되는 Bug라고 할 수 있습니다.</p>

<p><img src="/assets/img/os_concurrency_problem/order_violation.png" alt="order-violation" width="60%" height="60%" /></p>

<p>왼쪽의 그림에서도 Thread1과 Thread2가 모두 mThread라는 공유 자원에 접근합니다. 이와 같은 상황에서 atomicity를 위해 우리는 위와 같이 Lock을 사용했었죠. 그러나, 접근 <strong>순서</strong>가 명확하지 않아 버그가 발생하게 됩니다. 이 예시를 본다면 Thread1이 Create를 해줘야 Thread2가 사용할 수 있겠죠? 우리는 이를 위해 mInit이라는 <code class="language-plaintext highlighter-rouge">static variable</code>을 사용하였고, 이로 인해 발생되는 <code class="language-plaintext highlighter-rouge">Spin</code>의 비효율을 문제 삼아 <code class="language-plaintext highlighter-rouge">Condition Variables</code>를 사용했던 것을 기억하실 겁니다.</p>

<p>Non-Deadlock버그의 <strong>97%</strong>는 위에서 설명한 이 두가지 버그에 해당합니다. 그러나 위 예시와 같이 해결이 가능한 버그들이 다도 아닙니다.:sweat_smile: 이를 위해서는 프로그래머가 프로그램의 구조와 흐름을 더 깊게 이해하고 자동화된 코드 checking 도구가 뒷받침되어야 합니다.</p>

<h1 id="deadlock-bugs">Deadlock Bugs</h1>

<p>Semaphore에서 간단하게 다루었었던 <code class="language-plaintext highlighter-rouge">Deadlock</code>에 대해 더 알아봅시다. 아래는 가장 간단한 Deadlock 예시입니다.</p>

<p><img src="/assets/img/os_concurrency_problem/dead_ex(1).png" alt="dead-ex1" width="60%" height="60%" /></p>

<p>Thread1이 L1을 대상으로 Lock을 수행합니다. 그런데 여기서 Context Switching이 일어나 Thread가 L2에 대해 Lock을 수행합니다. 그리고 L1에 Lock을 수행하려고 하지만 Thread1에게 걸어져 있는 상태라 기다리게 됩니다. 이후에 다시 Thread1으로 Switching이 되어 L2에 Lock을 수행하려 하더라도 L2는 또 Thread2에게 걸어져 있어 Thread2를 기다리게 됩니다. 결국 이 둘은 서로를 기다리는 <code class="language-plaintext highlighter-rouge">교착 상태</code>에 빠지게 되는데 이를 그림으로 표현하면 아래와 같으며 <strong>Deadlock</strong>이라고 표현합니다.</p>

<p><img src="/assets/img/os_concurrency_problem/dead_ex(2).png" alt="dead-ex2" width="35%" height="35%" /></p>

<h1 id="왜-deadlock이-생기는-것일까요">왜 Deadlock이 생기는 것일까요?</h1>

<p>첫 번째로는 Componet들의 복잡한 의존관계 때문입니다. 하나의 메모리에 접근하는 여러 요소들, 그리고 그 요소들사이의 소통… 그 모종의 관계가 조금은 복잡한 양상을 하고 있습니다. 또 다른 이유로는 <code class="language-plaintext highlighter-rouge">Encapsulation</code>을 들 수 있겠습니다. 즉, 우리가 사용하는 함수(API)들은 훨씬 쉬운 사용을 위해 구현에 대한 디테일들은 숨기게 되는데 그로 인해 그것들을 사용하는 프로그래머들이 예상치 않게 Deadlock과 같은 문제를 마주할 수도 있는 것입니다. 더 나은 예시를 위해, 아래와 같은 코드를 살펴봅시다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Vector</span> <span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">;</span>
<span class="n">v1</span><span class="o">.</span><span class="na">AddAll</span><span class="o">(</span><span class="n">v2</span><span class="o">);</span> <span class="c1">//by Thread1</span>
<span class="n">v2</span><span class="o">.</span><span class="na">AddAll</span><span class="o">(</span><span class="n">v1</span><span class="o">);</span> <span class="c1">//by Thread2</span>
</code></pre></div></div>

<p>Thread1에서 v1.AddAll(v2)를 수행할 때는 내부적으로 multi-thread의 안정성을 위해서 v1에 Lock을 건 후 v2에 Lock을 걸게 됩니다. 그러나 동시에 Thread2가 v2.AddAll(v1)을 수행한다면 위의 Deadlock예시에서 설명드렸던 상황과 똑같은 일이 벌어지게 되는 것입니다…:cry:</p>

<p>DeadLock이 일어나기 위한 조건에는 4가지가 있습니다.</p>

<ul>
  <li>Mutual Exlusion
    <ul>
      <li>스레드가 리소스에 대한 독점적인 통제를 가지게 되는 것입니다.. 즉 Lock의 의의이기도 하며, 즉 Lock을 거는 것을 의미합니다. <del>(당연히 Lock같은 거 없으면 Deadlock이 안 생기겠지…)</del></li>
    </ul>
  </li>
  <li>Hold-and-wait
    <ul>
      <li>스레드가 할당 된 리소스를 잡고 있으면서 추가적인 리소스를 기다리는 것입니다.</li>
    </ul>
  </li>
  <li>No preemption
    <ul>
      <li>스레드가 잡고 있는 리소스(ex. Locks)를 강제적으로 뺏거나 제거할 수가 없습니다.</li>
    </ul>
  </li>
  <li>Circular wait
    <ul>
      <li>스레드가 잡고 있는 리소스가 다음 스레드의 요청을 받고 있으며 이것들이 마치 하나의 체인처럼 연결되어 있는 상황을 말합니다. 위에 설명했던 그림과 같은 상황을 의미합니다.</li>
    </ul>
  </li>
</ul>

<p>이 4가지가 전제되어야 Deadlock이 발생합니다. 즉,<strong>이것들이 하나라도 만족하지 않는다면</strong> Deadlock을 피할 수 있는 것입니다! 각각을 방지하기 위한 방법에 대해 알아보도록 하겠습니다.</p>

<h2 id="mutual-exclusion">Mutual Exclusion</h2>

<p><img src="/assets/img/os_concurrency_problem/mutual_exclusion.png" alt="mutual-exlusion" width="40%" height="40%" />
<img src="/assets/img/os_concurrency_problem/compare_and_swap.png" alt="cas" width="40%" height="40%" /></p>

<p>그림의 왼쪽 위의 코드와 같이 Lock을 사용하게 되면 <code class="language-plaintext highlighter-rouge">Mutual Exclusion</code>이 되어 lock과 unlock 사이를 수행하는 동안은 어떠한 스레드도 이 영역을 건드리지 못하게 됩니다. Lock은 그러려고 있는 게 맞습니다. 그러나 우리는 일단 Deadlock을 막고 싶은 것입니다. 그런데 우리는 Lock의 구현 중 <code class="language-plaintext highlighter-rouge">CompareAndSwap</code>에 대해서 공부한 적이 있습니다. (이 그림의 코드는 기댓값과 같을 시 성공의 1, 다를 시 실패의 0을 반환해줄 뿐 기댓값과 비교하는 CompareAndSwap의 개념에는 차이가 없습니다.)</p>

<p>왼쪽 아래와 같이 코드를 짜면 어떨까요? Critical Section안에는 <code class="language-plaintext highlighter-rouge">n-&gt;next = head;</code>와 <code class="language-plaintext highlighter-rouge">head = n;</code>이라는 두 줄의 코드가 있습니다. 그렇기에 우리는 첫 줄과 두 줄 사이에 다른 스레드가 끼어들지 않기를 바랄 뿐입니다. 그렇다고 독점을 행사하고 싶지도 않구요. 그래서 우리는 CompareAndSwap을 이용합니다. <code class="language-plaintext highlighter-rouge">n-&gt;next = head</code>를 수행 후 공유 자원에 변화가 생기지 않았다면 CompareAndSwap 내부에서 <code class="language-plaintext highlighter-rouge">head</code>와 <code class="language-plaintext highlighter-rouge">n-&gt;next</code>가 같다는 결과가 나올 것이고, 이 때 <code class="language-plaintext highlighter-rouge">head = n</code>을 자체적으로 실행하게 됩니다. 변화가 생겼다면 다시 처음부터 <code class="language-plaintext highlighter-rouge">n-&gt;next = head</code>를 실행하는 것이지요. 독점을 행사하는 않고 자기 자신이 스스로 확인하며 <code class="language-plaintext highlighter-rouge">synchronizaiton</code>에 신경 쓰는 모습을 볼 수 있습니다. 이를 <strong>lock-free 접근법</strong>이라고 하며, 이제 이 블로그 Locks의 CompareAndSwap부분 마무리에서  <code class="language-plaintext highlighter-rouge">lock-free synchronization</code>에 유리하다는 설명이 이제 이해가 가실 수 있을 겁니다.</p>

<h2 id="hold-and-wait">Hold-and-wait</h2>
:ET