I"<p>이번 시간에는 OS와 I/O로 소통하는 Device들에 대해 알아봅시다. 먼저 간단한 컴퓨터 시스템 구조부터 확인해볼까요?</p>

<p><img src="/assets/img/os-device/system_architecture.png" alt="system_architecture" width="50%" height="50%" /></p>

<p>시스템은 이와 같이 <code class="language-plaintext highlighter-rouge">Hierarchical</code> 구조를 띄고 있습니다. 가장 상단의 CPU와 Memory는 서로 <code class="language-plaintext highlighter-rouge">Memory bus</code>를 사용해서 데이터를 주고 받습니다. 아시다시피 모든 <code class="language-plaintext highlighter-rouge">bus</code> 중에 가장 빠르겠구요. 그 밑에는 모니터, 마우스, 키보드와 같은 주변기기들과 컴퓨터 메인보드를 연결하는 <code class="language-plaintext highlighter-rouge">I/O bus</code>가 위치합니다. 그리고 최하단에는 가장 느리지만 가장 용량이 큰 저장장치들이 <code class="language-plaintext highlighter-rouge">Peripheral bus</code>로 연결되어 있지요. 흔히 <code class="language-plaintext highlighter-rouge">Hardware</code>라고도 불리는 이 저장 장치에는 <code class="language-plaintext highlighter-rouge">SCSI</code>, <code class="language-plaintext highlighter-rouge">SATA</code>, 그리고 우리가 흔히 아는 <code class="language-plaintext highlighter-rouge">USB</code> 같은 프로토콜을 가집니다. 지금 우리가 공부할 부분이 바로 이 부분입니다.</p>

<p>Device에는 시스템 소프트웨어들이 제어를 할 수 있도록 3개의 <code class="language-plaintext highlighter-rouge">Hardware Interface Register</code>를 가집니다. 이는 아래와 같습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Status Register</code> : 디바이스의 현 상태를 확인하기 위해 읽어들이는 레지스터 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Command Register</code> : 디바이스에게 어떠한 task를 수행하도록 명령하기 위해 쓰는 레지스터 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Data Register</code> : 디바이스와 데이터를 주고받기 위한 레지스터입니다.</li>
</ol>

<p>내부 구조에 따라 Device도 크게 두 가지로 나뉠 수 있습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Simple Device</code> : 기능을 제공하기 위해 한 개 정도의 적은 <code class="language-plaintext highlighter-rouge">chip</code> 만을 가지는 디바이스 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Complex Device</code> : 단순히 몇몇 chip을 가지는 것을 넘어 아래와 같이 고유의 <code class="language-plaintext highlighter-rouge">fireware</code> 가 등록되어 있는 작은 <code class="language-plaintext highlighter-rouge">CPU</code>, CPU와 함께 동작하는 <code class="language-plaintext highlighter-rouge">Memory</code>, 그리고 다양한 용도의 많은 <code class="language-plaintext highlighter-rouge">chip</code>을 가짐으로 하나의 작은 컴퓨터로서 동작하는 디바이스 입니다.</li>
</ol>

<p><img src="/assets/img/os-device/complex_device.png" alt="complex_device" width="40%" height="40%" /></p>

<p>위에서 설명한 레지스터를 이용하여 컴퓨터는 간단하게 아래와 같이 디바이스와 소통할 수 있습니다.</p>

<p><img src="/assets/img/os-device/protocol_problem.png" alt="protocol_problem" width="40%" height="40%" /></p>

<p>그러나 위와 같이 수행할 경우 두 가지의 심각한 비효율성 문제가 야기 됩니다. 첫 번째는 CPU가 쉬지 안고 계속해서 Status register를 읽기 때문에 CPU의 낭비가 야기됩니다. 이 문제를 <code class="language-plaintext highlighter-rouge">Polling</code>이라 부릅니다. 두 번째는 컴퓨터의 메인 <code class="language-plaintext highlighter-rouge">CPU</code>가 데이터의 교환을 위해 직접 이와 같이 디바이스와 소통하기 때문에 마찬가지로 CPU의 낭비가 야기됩니다. 이 문제를 <code class="language-plaintext highlighter-rouge">Programmed I/O(PIO)</code>라 부릅니다.</p>

<h1 id="interrupt를-이용하자">Interrupt를 이용하자</h1>

<p><img src="/assets/img/os-device/interrupt.png" alt="interrupt" width="40%" height="40%" /></p>

<p>위의 문제 중 Polling의 문제를 해결하기 위해 도입된 것이 바로 <code class="language-plaintext highlighter-rouge">Interrupt</code>입니다. OS가 <code class="language-plaintext highlighter-rouge">I/O request</code>를 감지하며 해당 프로세스를 <code class="language-plaintext highlighter-rouge">Sleep</code> 시킨 후, <code class="language-plaintext highlighter-rouge">Context Switch</code>를 해서 다른 프로세스를 실행시킵니다. 그리고 디바이스가 요청된 작업이 다 끝나는 순간 <code class="language-plaintext highlighter-rouge">Hardware Interrupt</code>를 발생시키고</p>

:ET