I"@<p>OS에서 발생할 수 있는 <code class="language-plaintext highlighter-rouge">Concurrency Bugs</code>에는 크게 <code class="language-plaintext highlighter-rouge">Non-Deadlock</code>과 <code class="language-plaintext highlighter-rouge">DeadLock</code>이 있습니다. 먼저 Non-Deadlock에 대해 알아봅시다.</p>

<h1 id="non-deadlock-bugs">Non-Deadlock Bugs</h1>

<p><img src="/assets/img/os_concurrency_problem/atomicity_violation.png" alt="atomicity-violation" width="60%" height="60%" /></p>

<p>그림의 왼쪽과 같은 MySQL문을 봅시다. Thread1과 Thread2가 모두 thd-&gt;proc_info에 접근한다면 <code class="language-plaintext highlighter-rouge">atomicity</code>가 보장되지 않습니다. 이를 <code class="language-plaintext highlighter-rouge">Atomicity-Violation Bugs</code>라고 합니다. 그래서 우리느 오른쪽과 같이 <code class="language-plaintext highlighter-rouge">Lock</code>을 사용해 atomicity를 보장해야 하는 것이죠. 전에 공부하였던 Lock의 의의와는 직결되는 Bug라고 할 수 있습니다.</p>

<p><img src="/assets/img/os_concurrency_problem/order_violation.png" alt="order-violation" width="60%" height="60%" /></p>

<p>왼쪽의 그림에서도 Thread1과 Thread2가 모두 mThread라는 공유 자원에 접근합니다. 이와 같은 상황에서 atomicity를 위해 우리는 위와 같이 Lock을 사용했었죠. 그러나, 접근 <strong>순서</strong>가 명확하지 않아 버그가 발생하게 됩니다. 이 예시를 본다면 Thread1이 Create를 해줘야 Thread2가 사용할 수 있겠죠? 우리는 이를 위해 mInit이라는 <code class="language-plaintext highlighter-rouge">static variable</code>을 사용하였고, 이로 인해 발생되는 <code class="language-plaintext highlighter-rouge">Spin</code>의 비효율을 문제 삼아 <code class="language-plaintext highlighter-rouge">Condition Variables</code>를 사용했던 것을 기억하실 겁니다.</p>

<p>Non-Deadlock버그의 <strong>97%</strong>는 위에서 설명한 이 두가지 버그에 해당합니다. 그러나 위 예시와 같이 해결이 가능한 버그들이 다도 아닙니다.:sweat_smile: 이를 위해서는 프로그래머가 프로그램의 구조와 흐름을 더 깊게 이해하고 자동화된 코드 checking 도구가 뒷받침되어야 합니다.</p>

<h1 id="deadlock-bugs">Deadlock Bugs</h1>

<p>Semaphore에서 간단하게 다루었었던 <code class="language-plaintext highlighter-rouge">Deadlock</code>에 대해 더 알아봅시다. 아래는 가장 간단한 Deadlock 예시입니다.</p>

<p><img src="/assets/img/os_concurrency_problem/dead_ex(1).png" alt="dead-ex1" width="60%" height="60%" /></p>

<p>Thread1이 L1을 대상으로 Lock을 수행합니다. 그런데 여기서 Context Switching이 일어나 Thread가 L2에 대해 Lock을 수행합니다. 그리고 L1에 Lock을 수행하려고 하지만 Thread1에게 걸어져 있는 상태라 기다리게 됩니다. 이후에 다시 Thread1으로 Switching이 되어 L2에 Lock을 수행하려 하더라도 L2는 또 Thread2에게 걸어져 있어 Thread2를 기다리게 됩니다. 결국 이 둘은 서로를 기다리는 <code class="language-plaintext highlighter-rouge">교착 상태</code>에 빠지게 되는데 이를 그림으로 표현하면 아래와 같으며 <strong>Deadlock</strong>이라고 표현합니다.</p>

<p><img src="/assets/img/os_concurrency_problem/dead_ex(2).png" alt="dead-ex2" width="35%" height="35%" /></p>

<h1 id="왜-deadlock이-생기는-것일까요">왜 Deadlock이 생기는 것일까요?</h1>

<p>첫 번째로는 Componet들의 복잡한 <code class="language-plaintext highlighter-rouge">Dependencies</code> 때문입니다. 하나의 메모리에 접근하는 여러 요소들, 그리고 그 요소들사이의 소통… 그 모종의 관계가 조금은 복잡한 양상을 하고 있습니다. 또 다른 이유로는 <code class="language-plaintext highlighter-rouge">Encapsulation</code>을 들 수 있겠습니다. 즉, 우리가 사용하는 함수(API)들은 훨씬 쉬운 사용을 위해 구현에 대한 디테일들은 숨기게 되는데 그로 인해 그것들을 사용하는 프로그래머들이 예상치 않게 Deadlock과 같은 문제를 마주할 수도 있는 것입니다. 더 나은 예시를 위해, 아래와 같은 코드를 살펴봅시다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Vector</span> <span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">;</span>
<span class="n">v1</span><span class="o">.</span><span class="na">AddAll</span><span class="o">(</span><span class="n">v2</span><span class="o">);</span> <span class="c1">//by Thread1</span>
<span class="n">v2</span><span class="o">.</span><span class="na">AddAll</span><span class="o">(</span><span class="n">v1</span><span class="o">);</span> <span class="c1">//by Thread2</span>
</code></pre></div></div>

<p>Thread1에서 v1.AddAll(v2)를 수행할 때는 내부적으로 multi-thread의 안정성을 위해서 v1에 Lock을 건 후 v2에 Lock을 걸게 됩니다. 그러나 동시에 Thread2가 v2.AddAll(v1)을 수행한다면 위의 Deadlock예시에서 설명드렸던 상황과 똑같은 일이 벌어지게 되는 것입니다…:cry:</p>

<p>DeadLock이 일어나기 위한 조건에는 4가지가 있습니다.</p>

<ul>
  <li>Mutual Exlusion
    <ul>
      <li>스레드가 리소스에 대한 독점적인 통제를 가지게 되는 것입니다.. 즉 Lock의 의의이기도 하며, 즉 Lock을 거는 것을 의미합니다. <del>(당연히 Lock같은 거 없으면 Deadlock이 안 생기겠지…)</del></li>
    </ul>
  </li>
  <li>Hold-and-wait
    <ul>
      <li>스레드가 할당 된 리소스를 잡고 있으면서 추가적인 리소스를 기다리는 것입니다.</li>
    </ul>
  </li>
  <li>No preemption
    <ul>
      <li>스레드가 잡고 있는 리소스(ex. Locks)를 강제적으로 뺏거나 제거할 수가 없습니다.</li>
    </ul>
  </li>
  <li>Circular wait
    <ul>
      <li>스레드가 잡고 있는 리소스가 다음 스레드의 요청을 받고 있으며 이것들이 마치 하나의 체인처럼 연결되어 있는 상황을 말합니다. 위에 설명했던 그림과 같은 상황을 의미합니다.</li>
    </ul>
  </li>
</ul>

<p>이 4가지가 전제되어야 Deadlock이 발생합니다. 즉,<strong>이것들이 하나라도 만족하지 않는다면</strong> Deadlock을 피할 수 있는 것입니다! 각각을 방지하기 위한 방법에 대해 알아보도록 하겠습니다.</p>

<h2 id="mutual-exclusion">Mutual Exclusion</h2>

<p><img src="/assets/img/os_concurrency_problem/mutual_exclusion.png" alt="mutual-exlusion" width="40%" height="40%" />
<img src="/assets/img/os_concurrency_problem/compare_and_swap.png" alt="cas" width="40%" height="40%" /></p>

<p>그림의 왼쪽 위의 코드와 같이 Lock을 사용하게 되면 <code class="language-plaintext highlighter-rouge">Mutual Exclusion</code>이 되어 lock과 unlock 사이를 수행하는 동안은 어떠한 스레드도 이 영역을 건드리지 못하게 됩니다. Lock은 그러려고 있는 게 맞습니다. 그러나 우리는 일단 Deadlock을 막고 싶은 것입니다. 그런데 우리는 Lock의 구현 중 <code class="language-plaintext highlighter-rouge">CompareAndSwap</code>에 대해서 공부한 적이 있습니다. (이 그림의 코드는 기댓값과 같을 시 성공의 1, 다를 시 실패의 0을 반환해줄 뿐 기댓값과 비교하는 CompareAndSwap의 개념에는 차이가 없습니다.)</p>

<p>왼쪽 아래와 같이 코드를 짜면 어떨까요? Critical Section안에는 <code class="language-plaintext highlighter-rouge">n-&gt;next = head;</code>와 <code class="language-plaintext highlighter-rouge">head = n;</code>이라는 두 줄의 코드가 있습니다. 그렇기에 우리는 첫 줄과 두 줄 사이에 다른 스레드가 끼어들지 않기를 바랄 뿐입니다. 그렇다고 독점을 행사하고 싶지도 않구요. 그래서 우리는 CompareAndSwap을 이용합니다. <code class="language-plaintext highlighter-rouge">n-&gt;next = head</code>를 수행 후 공유 자원에 변화가 생기지 않았다면 CompareAndSwap 내부에서 <code class="language-plaintext highlighter-rouge">head</code>와 <code class="language-plaintext highlighter-rouge">n-&gt;next</code>가 같다는 결과가 나올 것이고, 이 때 <code class="language-plaintext highlighter-rouge">head = n</code>을 자체적으로 실행하게 됩니다. 변화가 생겼다면 다시 처음부터 <code class="language-plaintext highlighter-rouge">n-&gt;next = head</code>를 실행하는 것이지요. 독점을 행사하는 않고 자기 자신이 스스로 확인하며 <code class="language-plaintext highlighter-rouge">synchronizaiton</code>에 신경 쓰는 모습을 볼 수 있습니다. 이를 <strong>lock-free 접근법</strong>이라고 하며, 이제 이 블로그 Locks의 CompareAndSwap부분 마무리에서  <code class="language-plaintext highlighter-rouge">lock-free synchronization</code>에 유리하다는 설명이 이제 이해가 가실 수 있을 겁니다.</p>

<h2 id="hold-and-wait">Hold-and-wait</h2>

<p>다시 한 번 설명하자면 스레드 A가 어떠한 리소스는 <code class="language-plaintext highlighter-rouge">hold</code>하고 있고 어떤 리소스에 대해서는 <code class="language-plaintext highlighter-rouge">wait</code>하고 있기 때문에 Hold-and-wait 문제가 발생하게 됩니다. 이 때, 스레드 B가 A가 hold하고 있는 리소스를 <code class="language-plaintext highlighter-rouge">wait</code>하고 A가 wait하고 있는 리소스는 <code class="language-plaintext highlighter-rouge">hold</code>하고 있을 때 교착 상태, 즉 Deadlock이 발생하는 것을 우리는 몇 차례 확인한 바 있습니다. 이 것은 해결책은 생각보다 무식할 수 있습니다. 아래와 같이 그냥 이 일련의 Hold-and-wait과정을 <code class="language-plaintext highlighter-rouge">Lock</code>에 걸어버리는 겁니다.</p>

<p><img src="/assets/img/os_concurrency_problem/hold_wait.png" alt="hold-wait" width="60%" height="60%" /></p>

<p>그렇지만 이를 위해 우리는 Deadlock이 발생할 수 있는 Lock의 <code class="language-plaintext highlighter-rouge">Flow</code>를 잘 알고 있어야 합니다. (어디서 발생할 지 파악을 해야 Lock을 걸든 말든 하겠지요…) 또한, 이런식으로 전체를 막아버리는 과정은 <code class="language-plaintext highlighter-rouge">Concurrency</code>에 악영향을 미칠 수 밖에 없겠죠?:sweat_smile:</p>

<h2 id="no-preemption">No preemption</h2>

<p>리소스들이 맘대로 줬다 뺐다 할 수 없으니 상황을 보고 <code class="language-plaintext highlighter-rouge">hold</code>를 하자라는 겁니다. 그럴 때 우리가 쓸 수 있는 함수가 <code class="language-plaintext highlighter-rouge">pthread_mutex_trylock()</code>입니다. lock이 누군가에게 hold되고 있지 않으면 걸고 성공을 반환하고, 아니면 실패를 반환합니다.</p>

<p><img src="/assets/img/os_concurrency_problem/trylock.png" alt="trylock" width="60%" height="60%" /></p>

<p>위와 같은 코드로 Deadlock이 걸릴만한 상황인지를 체크하고 일련의 과정을 다시 시작할 수가 있습니다. 그러나 만약 프로세서가 여러 개라 이것들이 정말 동시에 구동돤다면 Lock을 걸고 해제하는 걸 무한 반복하는 최악의 상황을 마주할 수도 있습니다. 이를 전문 용어로 <code class="language-plaintext highlighter-rouge">Livelock</code>이라고 합니다. 이를 해결하기 위해 우리는 <code class="language-plaintext highlighter-rouge">random delay</code>로 스레드들의 실행 시점을 다르게 할 수 있습니다.</p>

<h2 id="circularwait">CircularWait</h2>

<p>리소스에 대한 <code class="language-plaintext highlighter-rouge">hold</code>와 <code class="language-plaintext highlighter-rouge">wait</code>이 서로 마치 체인처럼 연결되어 있는 것을 <code class="language-plaintext highlighter-rouge">CircularWait</code>이라고 했습니다. 이를 위해서는 서로 체인처럼 맞물릴 수 있는 순서를 피해야 합니다. 그렇기에 <code class="language-plaintext highlighter-rouge">Circular</code>이 아닌 <code class="language-plaintext highlighter-rouge">Sequential</code>하게 끔 연결될 수 있는 <code class="language-plaintext highlighter-rouge">Ordering</code>이 필요합니다. 예를 들어 스레드들이 모두 무조건적으로 L1을 Lock걸고 L2를 Lock걸도록 순서를 지정해줄 수 있습니다. 이렇게 전체에 대해서 순서를 지정해주는 것을 <code class="language-plaintext highlighter-rouge">Total  Ordering</code>이라고 부릅니다. 그러나 복잡한 시스템에서는 보통 여러 개의 Lock들이 존재하게 됩니다. 이럴 때는 전체에 대해 Ordering을 해주는 것이 아닌 부분적으로 필요한 부분만 Ordering을 해줄 수 있습니다. 예를 들어 A 후에 B가 와야하고 C 후에 D가 와야한다는 겁니다. 이를 <code class="language-plaintext highlighter-rouge">Partial Ordering</code>이라고 부르며, <code class="language-plaintext highlighter-rouge">linux File Memory Map</code>에서 다음 예시와 같이 Partial Ordering을 지정하고 있습니다.</p>

<p><img src="/assets/img/os_concurrency_problem/partial_ordering.png" alt="partial" width="60%" height="60%" /></p>

<p>부가적으로, <code class="language-plaintext highlighter-rouge">Encapsulation</code>의 문제도 수반될 수 있습니다. 예를 들어 위에서 설명한 Total Ordering으로 Lock의 순서를 지정해줬는데, 한 스레드는 <code class="language-plaintext highlighter-rouge">do something(L1, L2)</code>, 다른 스레드는 <code class="language-plaintext highlighter-rouge">do something(L2, L1)</code>을 호출하면 어떨까요? 매개변수의 순서로 도로아미타불이 되고 말 겁니다. 그래서 아래와 같이 매개변수 순서와는 상관없는 <code class="language-plaintext highlighter-rouge">Address</code>를 이용해서 이러한 문제를 해결하곤 한답니다.</p>

<p><img src="/assets/img/os_concurrency_problem/lock_address.png" alt="lock-address" width="60%" height="60%" /></p>

<h2 id="번외--dining-philosophers-problem">번외 : Dining Philosopher’s Problem</h2>

<p>Deadlock에 있어 유명한 Dining Philosopher’s Problem에 대해 알아보도록 합시다.</p>

<p>아래와 같이 5명의 철학자(프로세스 or 스레드) 양쪽에는 돼지고기(리소스)가 있습니다. 그들이 배가 차기 위해서는 양 쪽 돼지고기 2개를 모두 먹어야만 합니다. 그래서 철학자들은 왼쪽을 가져오고 오른쪽을 가져와서 먹기로 합니다. 이들이 모두 이 순세대로 움직여서 그들은 자신 왼쪽의 고기를 가져올 수 있었습니다.(hold) 그러나, 오른쪽의 고기는 오른쪽의 철학자가 가져갔기 때문에 기다리게 됩니다.(wait) 그렇다면 한 명도 먹지 못하고 계속 기다리게 되는 것이죠! 이렇듯 Deadlock이 생기는 이유에서 가장 처음 언급하였던 <code class="language-plaintext highlighter-rouge">Dependency</code> 문제 때문에도 교착이 발생하게 됩니다.</p>

<p>+왼쪽 후에 오른쪽을 가져오는 것이 Circularwait에서 Ordering을 하는 것이 아니냐라고 생각이 들 수 있습니다. 그러나 이건 상대적인 순서이지 절대적인 순서가 아닙니다. 이 문제에 공부했던 Ordering을 적용한다면, 돼지고기를 저 멀리 놓고 번호를 지정한 뒤 철학자들이 가져가야 할 순서를 매겨주는 것이겠지요. 위에 설명했던 Circularwait과는 다른 개념으로 이해해주시면 좋을 것 같습니다.:smile:</p>

<p><img src="/assets/img/os_concurrency_problem/dining_philosophers.png" alt="dining" width="60%" height="60%" /></p>

<p>이런 Dependency문제를 깨기 위해서 Dijkstra는 4명은 왼쪽 후 오른쪽, 나머지 한 명은 오른쪽 후 왼쪽을 가져가게끔 하였습니다.</p>

<p><img src="/assets/img/os_concurrency_problem/dining_dijkstra.png" alt="dining-dijkstra" width="60%" height="60%" /></p>

:ET