I"c<p>이번에는 <strong>Semaphore</strong>에 대해 알아보도록 합시다.</p>

<h1 id="semaphore란-무엇일까">Semaphore란 무엇일까?</h1>

<p>우리가 흔히 <code class="language-plaintext highlighter-rouge">Dijkstra Algorithm</code>으로 잘 알고 있는 Dijkstra는 공유 자원에 대한 접근을, 즉 동기화 문제를 위해 <code class="language-plaintext highlighter-rouge">Semaphore</code>라는 것을 만들었습니다. 우리는 이전에 배웠던 <code class="language-plaintext highlighter-rouge">Locks</code>와 <code class="language-plaintext highlighter-rouge">Condition Variables</code> 대신 이 하나의 Semaphore라는 것을 이용할 수 있는 거지요. 단순하게 생각하면 Semaphore는 그저 두 개의 <code class="language-plaintext highlighter-rouge">atomic operation</code>으로 관리되는 하나의 정적 변수에 불과한 개념입니다. 내용은 아래와 같습니다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;semaphore.h&gt; 
</span><span class="n">sem_t</span> <span class="n">s</span><span class="p">;</span>
<span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//performed atomically</span>
       <span class="n">decrement</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">by</span> <span class="n">one</span>
       <span class="n">wait</span> <span class="k">if</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">is</span> <span class="n">negative</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//performed atomically</span>
       <span class="n">increment</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">semaphore</span> <span class="n">s</span> <span class="n">by</span> <span class="n">one</span>
       <span class="k">if</span> <span class="n">there</span> <span class="n">are</span> <span class="n">one</span> <span class="n">or</span> <span class="n">more</span> <span class="n">threads</span> <span class="n">waiting</span><span class="p">,</span> <span class="n">wake</span> <span class="n">one</span>
<span class="p">}</span>
</code></pre></div></div>
<p>init의 마지막 parameter에서 Semaphore의 값을 초기화 합니다. <code class="language-plaintext highlighter-rouge">sem_wait</code>은 단순히 값을 1 줄입니다. 그리고 그 값이 음수가 된다면 <code class="language-plaintext highlighter-rouge">wait 상태(Sleeping State)</code>에 들어가게 됩니다. <code class="language-plaintext highlighter-rouge">sem_post</code>는 단순히 값을 1 증가합니다. 이 때 wait 상태에 있는 스레드들이 존재한다면 그 중 하나를 깨웁니다. 기본적인 사용법은 아래와 같이 <code class="language-plaintext highlighter-rouge">Critical Section</code>을 wait과 post로 감싸줍니다.</p>

<p><img src="/assets/img/os-condition-variable/semaphore_basic.png" alt="semaphore-basic" width="50%" height="50%" /></p>

<p>간단히 정리하자면 이와 같습니다. 먼저 Semaphore값을 처음 1로 설정하는 이유는</p>
:ET