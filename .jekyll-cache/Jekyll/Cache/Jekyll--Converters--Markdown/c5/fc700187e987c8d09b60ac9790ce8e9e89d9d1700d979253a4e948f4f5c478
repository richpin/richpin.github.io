I"<p>이번 시간에는 4계층 Transport Layer에서 가장 많이 들리는 <code class="language-plaintext highlighter-rouge">TCP</code>에 대해서 알아보는 시간을 가지도록 하겠습니다.</p>

<h1 id="tcp의-특성">TCP의 특성</h1>

<p>먼저, 당연하게도 TCP는 Transport Layer의 특성인 <code class="language-plaintext highlighter-rouge">Multiplexing</code>을 가집니다. 즉, 많은 Flow들이 서로 같은 링크(길)들을 공유하면서 지나가는 것이죠. 자동차 도로를 보더라도 많은 다른 자동차들이 간격만 유지한다면 다 같은 경로로 가는 것이 가능하죠? 네트워크 링크에서 패킷들도 마찬가지인 겁니다. TCP가 가지는 고유하는 특성은 <code class="language-plaintext highlighter-rouge">Byte-oriented</code>를 꼽을 수 있습니다. 패킷이 바이트 단위로 구성되있다는 것이죠. 그리고 그 바이트들은 서로를 구별하기 위해 <code class="language-plaintext highlighter-rouge">Label</code>을 가집니다. 그리고 이 바이트들이 모인 단위를 또 하나의 <code class="language-plaintext highlighter-rouge">Segment</code>라 칭합니다. <code class="language-plaintext highlighter-rouge">UDP</code>는 하나의 Message를 그 자체를 단위로 삼는 <code class="language-plaintext highlighter-rouge">Message-oriented(Chunk-oriented)</code>를 가지는 것과의 차이점이라 할 수 있습니다. 또한 TCP는 Connection의 <code class="language-plaintext highlighter-rouge">State</code>를 보유할 수 있지만, UDP에는 그런 것은 존재하지 않습니다.</p>

<p><img src="/assets/img/network_tcp/byte_stream.png" alt="byte_stream" width="50%" height="50%" /></p>

<p>위의 그림은 TCP를 사용하는 2개의 프로세스가 Conncection하는 장면을 나타낸 것입니다. 마치 서로의 프로세스가 하나의 <code class="language-plaintext highlighter-rouge">Tube</code>로 연결된 모습이죠? 이 튜브 내부에서는 수많은 <code class="language-plaintext highlighter-rouge">Byte Stream</code>이 흐르고 있으며, 이 바이트 스트림의 흐름은 하나의 <code class="language-plaintext highlighter-rouge">Chunk</code> 단위로 툭툭 쪼개질 수 있는데 그 쪼개진 단위를 <code class="language-plaintext highlighter-rouge">Segment</code>라 합니다.(패킷이라 생각해도 무방하겠죠?)</p>

<p>TCP는 <code class="language-plaintext highlighter-rouge">Error/Loss</code> 감지합니다. 먼저 TCP 헤더에는 Checksum이 있어서 Checksum이 Invalid한 Segment들은 조용히 버려지게 되죠. 또한 패킷을 받는 Receiver가 패킷에 Error가 없음을 확인하면 <code class="language-plaintext highlighter-rouge">Acknowledgment</code>를 보내게 되는데, Sender는 패킷을 보낸 뒤 이 Acknowledgment가 오는 시간을 측정하는 Timeout Mechanism이 있어 이 시간이 지나면 Error/Loss가 난 것으로 간주하게 됩니다. TCP에서는 이러한 Error/Loss가 감지되었을 때, 해당 패킷을 다시 전송하는 방식으로 해결하고 있는데요.</p>

<p><img src="/assets/img/network_tcp/sr_buffer.png" alt="sr_buffer" width="50%" height="50%" /></p>

<p>위와 같이 각각의 프로세스는 Connection마다 각자의 <code class="language-plaintext highlighter-rouge">Sending Buffer</code>와 <code class="language-plaintext highlighter-rouge">Receiving Buffer</code>을 가집니다. 그래서 보냈던 패킷을 이 Buffer에 저장해서 다시 재전송하는 것이 가능해지는 것이지요. 또한, 애초에 보내는 속도와 받는 속도가 같을 수가 없기 때문에 임시로 쌓아놓기 위해서도 결과적으로 Buffer가 필요할 수밖에 없습니다. IP에서는 줄줄 흐르는 Byte Stream의 형태로 데이터를 전송하는 것이 불가능하기 때문에, TCP가 이를 Segment 단위로 자릅니다. 그리고 TCP는 그 Segment앞에 자기 자신의 TCP 헤더를 붙여 IP에 전달하게 되고 그걸 IP가 또 자기 자신의 IP 헤더로 Encapsulation해서 전송을 하게 되는 것이지요.</p>

<p>이와 더불어, TCP는 송/수신이 각각 다른 독립적인 링크에서 일어나 양방향 통신이 동시에 일어날 수 있기에 <code class="language-plaintext highlighter-rouge">Full-duplex Service</code>라고 불립니다. 또한, 아까 두 개의 프로세스가 하나의 튜브로 연결되어 있는 그림을 보셨죠? 이와 같이 양쪽이 송수신 전에 확실하게 Connection을 맺기 때문에 <code class="language-plaintext highlighter-rouge">Connection-oriented Service</code>라고 불립니다. 그리고 간단히 언급하였듯이 <code class="language-plaintext highlighter-rouge">Acknowledgment</code>를 이용해 데이터의 도착이 안전하고 알맞게 일어났는 지를 보장할 수 있기에 <code class="language-plaintext highlighter-rouge">Reliable Service</code>이기도 합니다.</p>

<p><img src="/assets/img/network_tcp/byte_numbering.png" alt="byte_numbering" width="50%" height="50%" /></p>

<p>TCP는 Byte Stream이기 때문에 특이하게도 Segment가 아닌 모든 Bytes에 번호를 붙입니다. 그리고 이 번호는 방향마다 독립적이기 때문에 보내는 방향과 오는 방향의 번호가 같을 수는 있습니다. 그치만, 그 방향 내에서는 독립적인 번호를 가져야만 하는 것이지요. 이 번호는 0부터 시작할 필요는 없습니다. 그래서 처음 보허는 Random하게 0과 2^32-1 사이에서 정해지는데 이를 <code class="language-plaintext highlighter-rouge">Initial Sequence Number(ISN)</code>이라고 합니다. 그리고 TCP는 이 번호들을 Segment 단위로 잘라 첫 번째 번호를 Segment에게 부여하는데 이 번호를 <code class="language-plaintext highlighter-rouge">Sequence Number</code>라고 합니다. 위의 그림과 같이 첫 번째 Segment가 저렇다면 두 번째 Segemnt의 Sequence Number는 마지막 번호에 1을 더한 11010이 되겠지요?:wink:</p>

:ET