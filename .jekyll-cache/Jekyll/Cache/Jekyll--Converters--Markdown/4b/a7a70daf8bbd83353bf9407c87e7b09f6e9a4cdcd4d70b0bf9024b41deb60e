I"<p>이번에는 저번시간에 이어 Lock에 대해 더 자세히 알아보는 시간을 가져봅시다.</p>

<h1 id="lock이란-무엇일까">Lock이란 무엇일까?</h1>

<p><code class="language-plaintext highlighter-rouge">Lock</code>은 critical section을 지키기 위해, 즉 Mutual Exclusion을 위해 사용하는 방법입니다. Lock 변수는 아래와 같은 두가지 상태를 저장할 수 있습니다.</p>

<ul>
  <li>Avaliable(unlocked, free한 상태)</li>
  <li>Acquired(locked, held한 상태)
즉 Acquired한 상태에서 다른 스레드가 lock을 시도하는 것을 <code class="language-plaintext highlighter-rouge">acquire a lock</code>이라고 표현하면 되겠습니다. 또한 lock을 현재 hold하고 있는 스레드를 <code class="language-plaintext highlighter-rouge">owner</code>이라 칭합니다. owner가 unlock을 호출해줄 때 비로소 해당 lock 변수에 대해 다른 스레드가 lock을 시도할 수 있는 상태가 되는 것입니다. 기본 사용법은 아래와 같습니다.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">Pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">Pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>

<p>lock 구현할 때 고려해봐야 하는 사항들은 아래와 같습니다.</p>

<ul>
  <li>Mutual Exclusion - mutual Exclusion을 완벽히 보장하는가?</li>
  <li>Fairness - 여러 스레드가 있을 때, 각가의 스레드가 lock을 걸 기회가 공정하게 주어지는가?</li>
  <li>Performance - single CPU, multi CPU에서 time overhead가 어떻게 도출되는가?</li>
</ul>

<h1 id="lock을-구현하기-위한-방법">Lock을 구현하기 위한 방법</h1>

<p>그렇다면 이제 이 Lock을 구현하는 방법은 어떤 것이 있고 어떻게 발전되어 왔는지 알아보도록 하겠습니다.</p>

<h2 id="controlling-interrupts">Controlling Interrupts</h2>

<p>가장 초창기에는 critical section안에서 <code class="language-plaintext highlighter-rouge">interrupt</code>을 <code class="language-plaintext highlighter-rouge">disable</code>하는 방식으로 mutual exclusion을 제공하려 하였습니다. 매우 간단하는 장점이 앞서지만 그에 비해 아래와 같은 단점들이 너무 많았습니다.</p>

<ol>
  <li>interrupt를 켜고 끄기 위해 <code class="language-plaintext highlighter-rouge">previleged</code>한 권한이 필요하게 됩니다.</li>
  <li>여러 프로세서가 있는 <code class="language-plaintext highlighter-rouge">Mutliprocessors</code> 시스템에서는 동작하지 않게 됩니다.</li>
  <li>interrupt가 강제적으로 막혀 있다는 것 자체가 현대에서는 실행을 느리게 하며 비효율적이라는 점을 피할 수 없습니다.</li>
</ol>

<h2 id="using-loadsstores">Using Loads/Stores</h2>

<p>thread에서 spin을 설명했을 때와 같이 그냥 하나의 <code class="language-plaintext highlighter-rouge">flag variable</code>을 이용하는 방법입니다.</p>

<p><img src="/assets/img/os_locks/load_and_store.png" alt="load_store" width="60%" height="60%" /></p>

<p>하지만 위에서 표시한대로 저 시점에 interrupt가 발생해 context switching이 된다면 양 스레드가 모두 while문을 가볍게 통과한 후 flag=1을 수행해 애시당초에 <strong>mutual exclusion을 보장하지 못합니다.</strong></p>

<h2 id="petersons-algorithm">Peterson’s Algorithm</h2>
:ET