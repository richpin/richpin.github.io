I",<p>이번 시간에는 OS와 I/O로 소통하는 Device들에 대해 알아봅시다. 먼저 간단한 컴퓨터 시스템 구조부터 확인해볼까요?</p>

<p><img src="/assets/img/os-device/system_architecture.png" alt="system_architecture" width="50%" height="50%" /></p>

<p>시스템은 이와 같이 <code class="language-plaintext highlighter-rouge">Hierarchical</code> 구조를 띄고 있습니다. 가장 상단의 CPU와 Memory는 서로 <code class="language-plaintext highlighter-rouge">Memory bus</code>를 사용해서 데이터를 주고 받습니다. 아시다시피 모든 <code class="language-plaintext highlighter-rouge">bus</code> 중에 가장 빠르겠구요. 그 밑에는 모니터, 마우스, 키보드와 같은 주변기기들과 컴퓨터 메인보드를 연결하는 <code class="language-plaintext highlighter-rouge">I/O bus</code>가 위치합니다. 그리고 최하단에는 가장 느리지만 가장 용량이 큰 저장장치들이 <code class="language-plaintext highlighter-rouge">Peripheral bus</code>로 연결되어 있지요. 흔히 <code class="language-plaintext highlighter-rouge">Hardware</code>라고도 불리는 이 저장 장치에는 <code class="language-plaintext highlighter-rouge">SCSI</code>, <code class="language-plaintext highlighter-rouge">SATA</code>, 그리고 우리가 흔히 아는 <code class="language-plaintext highlighter-rouge">USB</code> 같은 프로토콜을 가집니다. 지금 우리가 공부할 부분이 바로 이 부분입니다.</p>

<p>Device에는 시스템 소프트웨어들이 제어를 할 수 있도록 3개의 <code class="language-plaintext highlighter-rouge">Hardware Interface Register</code>를 가집니다. 이는 아래와 같습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Status Register</code> : 디바이스의 현 상태를 확인하기 위해 읽어들이는 register 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Command Register</code> : 디바이스에게 어떠한 task를 수행하도록 명령하기 위해 쓰는 register 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Data Register</code> : 디바이스와 데이터를 주고받기 위한 register입니다.</li>
</ol>

<p>내부 구조에 따라 Device도 크게 두 가지로 나뉠 수 있습니다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Simple Device</code> : 기능을 제공하기 위해 한 개 정도의 적은 <code class="language-plaintext highlighter-rouge">chip</code> 만을 가지는 디바이스 입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Complex Device</code> : 단순히 몇몇 chip을 가지는 것을 넘어 아래와 같이 고유의 <code class="language-plaintext highlighter-rouge">fireware</code> 가 등록되어 있는 작은 <code class="language-plaintext highlighter-rouge">CPU</code>, CPU와 함께 동작하는 <code class="language-plaintext highlighter-rouge">Memory</code>, 그리고 다양한 용도의 많은 <code class="language-plaintext highlighter-rouge">chip</code>을 가짐으로 하나의 작은 컴퓨터로서 동작하는 디바이스 입니다.</li>
</ol>

<p><img src="/assets/img/os-device/complex_device.png" alt="complex_device" width="55%" height="55%" /></p>

<p>위에서 설명한 register를 이용하여 컴퓨터는 간단하게 아래와 같이 디바이스와 소통할 수 있습니다.</p>

<p><img src="/assets/img/os-device/protocol_problem.png" alt="protocol_problem" width="55%" height="55%" /></p>

<p>그러나 위와 같이 수행할 경우 두 가지의 심각한 비효율성 문제가 야기 됩니다. 첫 번째는 CPU가 쉬지 안고 계속해서 Status register를 읽기 때문에(poll) CPU의 낭비가 야기됩니다. 이 문제를 <code class="language-plaintext highlighter-rouge">Polling</code>이라 부릅니다. 두 번째는 컴퓨터의 메인 <code class="language-plaintext highlighter-rouge">CPU</code>가 데이터의 교환을 위해 직접 움직이기 때문에 마찬가지로 CPU의 낭비가 야기됩니다. 이 문제를 <code class="language-plaintext highlighter-rouge">Programmed I/O(PIO)</code>라 부릅니다.</p>

<h1 id="interrupt를-이용하자">Interrupt를 이용하자</h1>

<p><img src="/assets/img/os-device/interrupt.png" alt="interrupt" width="50%" height="50%" /></p>

<p>위 두 문제를 해결하기 위해 도입된 것이 바로 <code class="language-plaintext highlighter-rouge">Interrupt</code>입니다. OS가 <code class="language-plaintext highlighter-rouge">I/O request</code>를 감지하면 해당 프로세스(그림의 A)를 <code class="language-plaintext highlighter-rouge">Sleep</code> 시킨 후, <code class="language-plaintext highlighter-rouge">Context Switch</code>를 해서 다른 프로세스(그림의 B)를 실행시킵니다. 그리고 디바이스가 요청된 작업이 다 끝나는 순간 <code class="language-plaintext highlighter-rouge">Hardware Interrupt</code>를 발생시킵니다. 그러면 CPU는 OS의 <code class="language-plaintext highlighter-rouge">Interrupt Service Routine(ISR)</code>을 동작시킨 후 I/O를 기다리며 Sleep하고 있던 프로세스(그림의 A)를 깨우게 됩니다. 이런식으로 Computation과 I/O가 어느 정도 겹쳐서 동작하게끔 함으로써 Poling과 PIO문제를 해결할 수 있는 것입니다.</p>

<p>그러나 만약 디바이스가 너무 빨라서 순식간에 interrupt를 할 경우에는 어떨까요? Context Switching을 할 시간조차 없겠죠? 즉, Interrupt를 하는 의미가 없어지게 되는 것입니다. 이럴 때는 그냥 <code class="language-plaintext highlighter-rouge">poll</code>을 하는 방식이 더 효과적일 수 있습니다. 그래서 보통은 처음엔 poll을 하다가 디바이스가 빨리 도착하지 않으면 어느 시점에서 Interrupt 모드로 전환하는 <code class="language-plaintext highlighter-rouge">Two-phased Approach</code>즉 <code class="language-plaintext highlighter-rouge">Hybrid</code> 방식을 채택하고는 합니다.</p>

<p>예를 들어, 네트워크 시스템을 생각해 봅시다. 여기서는 평화롭다가도 어느 시점에서 패킷이 들어오게 되면 엄청난 양의 스트림에 대해서 계속해서 Interrupt가 발생하게 됩니다. 자칫하면 OS가 <code class="language-plaintext highlighter-rouge">Livelock</code>에 걸리게 되는 것이지요. 이럴 때는 오히려 패킷이 들어오기 시작할때 Poll 모드를 사용하는 것이 바람직한 방법이게 됩니다.</p>

<p>그래도 Poll 모드가 맘에 들지 않는다구요? 그렇다면 Interrupt 발생 overhead를 줄이기 위해 여러 번의 Interrupt를 하나의 Interrupt로 합쳐서 받아들이는 방법도 있겠습니다. 이를 <code class="language-plaintext highlighter-rouge">Interrupt Coalescing</code>이라고 합니다. 그러나, 합쳐질 만큼 많은 Interrupt를 기다려야 하기 때문에 request의 <code class="language-plaintext highlighter-rouge">Latency</code>가 올라가는 단점이 존재하게 됩니다.</p>

<h1 id="direct-memory-accessdma를-이용하자">Direct Memory Access(DMA)를 이용하자</h1>

<p>위에서 Interrupt를 활용해서 디바이스와 CPU에 대한 PIO 문제를 어느 정도 감소시킨 바 있는데요. 이런 상황이면 어떨까요?</p>

<p><img src="/assets/img/os-device/not_dma.png" alt="not_dma" width="40%" height="40%" /></p>

<p>위의 그림을 봅시다. 우리가 Interrupt를 이용한 덕분에 디바이스가 1에 대한 request를 수행하는 동안 CPU가 Process2를 실행하는 것을 보실 수 있죠? 그런데 이 디바이스가 수행하는 1이라는 request가 메모리 상의 많은 데이터를 디바이스로 옮기는 작업이라고 해봅시다. 그렇다면 필연적으로 CPU에서는 메모리를 <code class="language-plaintext highlighter-rouge">Copy</code> 해놓는 작업이 선행되어야 하는데요. 이 또한 비효울적이라 이겁니다! 그래서 OS가 CPU가 아니더라도 Memory에 접근해서 CPU가 하는 일을 덜어주겠다고 만든 것이 바로 <code class="language-plaintext highlighter-rouge">Direct Memory Access(DMA)</code>입니다. 꽤나 직관적인 이름이죠?</p>

<p><img src="/assets/img/os-device/dma.png" alt="dma" width="40%" height="40%" /></p>

<p>덕분에 위와 같이 Copy하기 위한 시간마저 DMA가 해주어 CPU는 그동안 다른 프로세스들을 실행시킬 수 있게 되는 것입니다. DMA는 자신이 할 일이 끝났으면 Interrupt만 발생시켜 OS에게 끝냈다고 말만 해주면 되는 것이죠.</p>

<h1 id="device-driver">Device Driver</h1>

<p>그렇다면 보다 구체적으로 어떻게 디바이스와 <code class="language-plaintext highlighter-rouge">I/O Communication</code>을 할 수 있을까요? 맨 처음에는 <code class="language-plaintext highlighter-rouge">I/O Instruction</code>을 사용하였습니다. Intelx86의 in과 out같은 명령어를 예로 들 수 있습니다. 데이터를 담을 register와 디바이스를 지정할 포트 번호를 지정하여 데이터를 전송하죠. 그러나 이것들은 모두 <code class="language-plaintext highlighter-rouge">Privileged</code>한 Instruction이라는 단점이 존재하였습니다.그래서 이제는 디바이스의 register 위치를 Memory Address Space의 한 공간에 저장하였으며, 이를 <code class="language-plaintext highlighter-rouge">Memory Mapped I/O</code>라고 부릅니다.</p>

<p>그러나 이 방법 또한, 새로운 Instrution에 대한 대처를 따로 해줘야 한다는 것이었습니다. 계속해서 새로운 디바이스 protocol은 쏟아지고 개발자들이 이를 항상 직접 관리하는 것은 부담스러운 일이었죠. 그래서 개발자들은 이렇게 디바이스와 Interaction하는 부분의 세세한 코드는 OS의 하위 시스템으로 <code class="language-plaintext highlighter-rouge">Abstraction</code>을 해놓자는 결론에 이르렀습니다. 여기서 그 해당 코드를 담고 있는 부분이 바로 <code class="language-plaintext highlighter-rouge">Device Driver</code> 입니다.</p>

<p><img src="/assets/img/os-device/device_driver.png" alt="device_drvier" width="50%" height="50%" /></p>

<p>위와 같은 계층 구조로서 우리가 사용하는 파일 시스템상에서 <code class="language-plaintext highlighter-rouge">Block Request</code>를 보내면 <code class="language-plaintext highlighter-rouge">Generic Block Layer</code>가 그 해당 Request에 맞는 Device Driver을 찾아서 정보를 전달하고 Device Driver에서 실질적은 Ineraction을 처리하는 것입니다. 그렇기 때문에 Interaction이 간편해 진 것은 물론이고 새로운 디바이스를 장착하더라도 매칭하는 Device Driver만 껴주면 되기 때문에 굉장히 효율적입니다.</p>

<p>그러나 이런 <code class="language-plaintext highlighter-rouge">Encapsulation</code>으로 인한 문제도 존재합니다. 어떤 디바이스가 남들과는 다른 특별한 기능이 있더라도 위 계층들과 호환이 맞지 않아 사용을 못할 수도 있는 것이지요. 그 뿐만 아니라 이러한 Device Driver들이 OS 코드의 70% 이상을 차지하기 때문에 OS를 무겁게 하는 주범이 되기도 합니다.:cry:</p>

:ET